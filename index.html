<!DOCTYPE html>
<meta charset="utf-8">
<html>

<head>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/topojson.v2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.0/d3-legend.js"></script>
    <script src="d3-legend.min.js"></script>
    <meta charset="utf-8">
    <title>Airbnb New York 2019</title>
    <style type="text/css">
    #boroughs {
        stroke: none;
        stroke-width: 0px;
        fill: green;
        opacity: .9;
        position: absolute;
        top: 0;
        left: 0;
    }

    #routes {
        stroke: gray;
        stroke-width: 2;
        fill: none;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 100;
    }

    #stations {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 150;
        fill: #333;
    }

    .zoom {
        cursor: move;
        fill: none;
        pointer-events: all;
    }

    .axis {
        stroke-width: 0.5px;
        stroke: #888;
        font: 10px avenir next, sans-serif;
    }

    .axis>path {
        stroke: #888;
    }

    body {
        font-size: 12px;
        font-family: 'Open Sans', sans-serif;
        font-weight: 400;
        text-align: center;
    }

    label{
        font-size: 12px;
    }

    #title {
        font-size: 36px;
        padding-bottom: 10px;
        padding-top: 20px;
        font-weight: 300;
    }

    #explanation {
        font-size: 16px;
        max-width: 960px;
        margin: 0 auto;
        padding-top: 10px;
        color: #484848;
        font-weight: 300;
    }

    #tooltip {
        position: absolute;
        width: 300px;
        height: auto;
        padding: 10px;
        background-color: white;
        -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
        border-radius: 10px;
        -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        pointer-events: none;
    }

    #tooltip.hidden {
        display: none;
    }

    #tooltip p {
        margin: 0;
        font-family: sans-serif;
        font-size: 16px;
        line-height: 20px;
        text-align: left;
        font-family: 'Open Sans', sans-serif;
    }
    </style>
</head>

<body>
    <div id="tooltip" class="hidden">
        <p>Name : <strong id="name"></strong><br><br></p>
        <p>Host Name : <span id="host_name"></span></p>
        <p>Region : <span id="neighbourhood_group"></span></p>
        <p>Type : <span id="room_type"></span></p>
        <p>Price : <span id="price"></span></p>
        <p>Minimum Nights : <span id="minimum_nights"></span></p>
        <p>Number of Reviews : <span id="number_of_reviews"></span></p>
        <p>Last Review Time : <span id="review_time"></span></p>
        <p>Host Count Days : <span id="calculated_host_listings_count"></span></p>
        <p>Availability in a Year : <span id="availability_365"></span></p>
    </div>
    <div id="title">New York City Airbnb(2019)</div>
    <div id="chart"></div>
    <div id="explanation">Since 2008, guests and hosts have used Airbnb to expand on traveling possibilities and present more unique, personalized way of experiencing the world. This dataset describes the listing activity and metrics in NYC, NY for 2019.<br>
        <br>This data file includes all needed information to find out more about hosts, geographical availability, necessary metrics to make predictions and draw conclusions.<br><br></div>
    <!-- Button -->
    <form>
        <input id="check1" type="checkbox" class="checkbox" value="Bronx" checked><label>Bronx</label>
        <input id="check2" type="checkbox" class="checkbox" value="Brooklyn" checked><label>Brooklyn</label>
        <input id="check3" type="checkbox" class="checkbox" value="Manhattan" checked><label>Manhattan</label>
        <input id="check4" type="checkbox" class="checkbox" value="Queens" checked><label>Queens</label>
        <input id="check5" type="checkbox" class="checkbox" value="Staten Island" checked><label>Staten Island</label>
    </form>
    <!-- Button -->
    <form id="room">
        <input type="radio" name="filterPreset" id="Entire" checked><label>Entire home/apt</label>
        <input type="radio" name="filterPreset" id="Private"><label>Private room</label>
        <input type="radio" name="filterPreset" id="Shared"><label>Shared room</label>
    </form>
    <form>
        <label for="input_year" style="width: 240px; text-align: right">
            Year = <span id="input_year-value"></span>
        </label>
        <input type="range" min="2011" max="2019" id="input_year">
    </form>
    <div style="float: left;"><svg id="svg1"></svg></div>
    <div style="float: left; padding-left: 50px" id="legend1"><label style="line-height:50px; vertical-align: top;">Number of Reviews </label></div>
    <div style="float: left; padding-left: 50px" id="legend2"><label style="line-height:50px; vertical-align: top;">Calculated Host Listings Count </label></div>
    <div style="float: left; padding-left: 50px" id="legend3"><label style="line-height:50px; vertical-align: top;">Map Legend </label></div>
    <div style="float: left padding-left: 50px;" id="totalDistance"><svg id="svg2"></svg></div>
</body>
<script>
document.getElementById("input_year").value = 2019;
var slider = document.getElementById("input_year");
var output = document.getElementById("input_year-value");
output.innerHTML = slider.value;

slider.oninput = function() {
    output.innerHTML = this.value;
}

var w1 = 300,
    h1 = 50;

var key = d3.select("#legend1")
    .append("svg")
    .attr("width", w1)
    .attr("height", h1);

var legend = key.append("defs")
    .append("svg:linearGradient")
    .attr("id", "gradient")
    .attr("x1", "0%")
    .attr("y1", "100%")
    .attr("x2", "100%")
    .attr("y2", "100%")
    .attr("spreadMethod", "pad");

legend.append("stop")
    .attr("offset", "0%")
    .attr("stop-color", "#084081")
    .attr("stop-opacity", 1);

legend.append("stop")
    .attr("offset", "33%")
    .attr("stop-color", "#7bccc4")
    .attr("stop-opacity", 1);

legend.append("stop")
    .attr("offset", "66%")
    .attr("stop-color", "#bae4bc")
    .attr("stop-opacity", 1);

legend.append("stop")
    .attr("offset", "100%")
    .attr("stop-color", "#f7fcf0")
    .attr("stop-opacity", 1);

key.append("rect")
    .attr("width", w1)
    .attr("height", h1 - 30)
    .style("fill", "url(#gradient)")
    .attr("transform", "translate(20,10)");

var y = d3.scaleLinear()
    .range([300, 0])
    .domain([629, 1]);

var yAxis = d3.axisBottom()
    .scale(y)
    .ticks(5);

key.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(20,30)")
    .call(yAxis)
    .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 0)
    .attr("dy", ".71em")
    .style("text-anchor", "end")

var w2 = 300,
    h2 = 50;

var key1 = d3.select("#legend2")
    .append("svg")
    .attr("width", w2)
    .attr("height", h2);

var linearSize = d3.scaleLinear().domain([1,327]).range([1.01, 4.27]);

key1.append("g")
  .attr("class", "legendSize")
  .attr("transform", "translate(20, 10)");

var legendSize = d3.legendSize()
  .scale(linearSize)
  .shape('circle')
  .shapePadding(50)
  .labelOffset(20)
  .labelFormat(d3.format(".0f"))
  .orient('horizontal');

key1.select(".legendSize")
    .call(legendSize)

var w3 = 300,
    h3 = 100;

var key2 = d3.select("#legend3")
    .append("svg")
    .attr("width", w3)
    .attr("height", h3);

var triangleU = d3.symbol().type(d3.symbolTriangle)(),
  circle = d3.symbol().type(d3.symbolCircle)(),
  cross = d3.symbol().type(d3.symbolCross)(),
  diamond = d3.symbol().type(d3.symbolDiamond)(),
  star = d3.symbol().type(d3.symbolStar)();

//example output of d3.svg.symbol().type('circle')();
//"M0,4.51351666838205A4.51351666838205,4.51351666838205 0 1,1 0,
//-4.51351666838205A4.51351666838205,4.51351666838205 0 1,1 0,4.51351666838205Z"

var symbolScale =  d3.scaleOrdinal()
  .domain(['Airbnb','Subway'])
  .range([ circle, cross] );

key2.append("g")
  .attr("class", "legendSymbol")
  .attr("transform", "translate(50, 20)");

var legendPath = d3.legendSymbol()
  .scale(symbolScale)
  .orient("horizontal")
  .labelWrap(30)
  .shapePadding(50)
  .labelOffset(20)
  .on("cellclick", function(d){alert("clicked " + d);});

key2.select(".legendSymbol")
  .call(legendPath);

var w = 600;
h = 500;

var svg1 = d3.select("#svg1")
    .style("width", w + "px")
    .style("height", h + "px")
    .attr("width", "100%")
    .attr("height", "100%")
    .call(d3.zoom().on("zoom", function() {
        svg1.attr("transform", d3.event.transform)
    }))
    .append("g")

var projection = d3.geoMercator()
    .center([-73.94, 40.70])
    .scale(80000)
    .translate([(w) / 2, (h) / 2]);

var path = d3.geoPath()
    .projection(projection);

var allCircles = svg1.selectAll("circle")

d3.json("nyc.json", function(error, nyb) {
    if (error) throw error;
    svg1.selectAll(".state")
        .data(nyb.features)
        .enter().append("path")
        .attr("class", function(d) { return d.properties.name; })
        .attr("d", path)
        .attr("stroke", "#767676")
        .attr("fill", "none")

});

d3.json("routes.json", function(routes) {
    svg1.selectAll(".path")
        .data(topojson.feature(routes, routes.objects.nyctsubwayroutes_100627).features)
        .enter().append("path")
        .attr("d", path)
        .attr("stroke", "#FC642D")
        .attr("fill", "none")

});

d3.csv("stops.csv", function(stops) {
    svg1.selectAll(".stop")
        .data(stops)
        .enter().append("rect")
        .attr("width", 5)
        .attr("height", 5)
        .attr("stroke", "none")
        .attr("fill", "#FC642D")
        .attr("x", function(d) { return projection([d.STOP_LON, d.STOP_LAT])[0] })
        .attr("y", function(d) { return projection([d.STOP_LON, d.STOP_LAT])[1] })

});

d3.csv("AB_NYC_2019.csv", function(data_review) {

    function update_points(year) {
        svg1.selectAll("circle").remove()
        var y = document.getElementById("input_year").value;
        var choices = [];
        d3.selectAll(".checkbox").each(function(d, i) {
            cb = d3.select(this);
            grp = cb.property("value")
            if (cb.property("checked")) {
                choices.push(cb.property("value"));
                console.log(choices);

            }
        });

        var form = document.getElementById("room");
        var form_val;
        for (var i = 0; i < form.length; i++) {
            if (form[i].checked) {
                form_val = form[i].id;
            }
        }

        var colors = d3.scaleQuantize()
            .domain([1, 629])
            .range(["#084081", "#7bccc4", "#bae4bc", "#f7fcf0"]);

        svg1.selectAll("circle")
            .data(data_review.filter(function(d) {
                return ((d.last_review == year | d.last_review == y) && (d.number_of_reviews >= 1 | d.calculated_host_listings_count >= 1) && d.room_type == form_val &&
                    (d.neighbourhood_group == choices[0] | d.neighbourhood_group == choices[1] | d.neighbourhood_group == choices[2] | d.neighbourhood_group == choices[3] | d.neighbourhood_group == choices[4]));
            }))
            .enter()
            .append("circle")
            .attr("class", function(d, i) { return d.neighbourhood_group })
            .attr("cx", function(d, i) { return projection([+d.longitude, +d.latitude])[0] })
            .attr("cy", function(d, i) { return projection([+d.longitude, +d.latitude])[1] })
            .attr("stroke", "none")
            .attr("fill", d => colors(d.number_of_reviews))
            .style("opacity", 0.5)
            .transition()
            .duration(1000)
            .ease(d3.easeCubic)
            .attr("r", function(d, i){
              return 1 + (0.01 * (+d.calculated_host_listings_count));
            })


        svg1.selectAll("circle")
            .on("mouseover", function(d, i) {
                //this.parentNode.appendChild(this);//the path group is on the top with in its parent group

                d3.select(this).style('stroke', '#484848');
                d3.select(this).style("stroke-width", 1);
                d3.select(this).style("stroke-opacity", 1);
                d3.select(this).style("opacity", 1);

                //Get this bar's x/y values, then augment for the tooltip
                var xPosition = 0;
                var yPosition = 100;

                //Update the tooltip position and value
                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#name")
                    .text(d.name);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#host_name")
                    .text(d.host_name);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#neighbourhood_group")
                    .text(d.neighbourhood_group);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#room_type")
                    .text(d.room_type);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#price")
                    .text(d.price);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#minimum_nights")
                    .text(d.minimum_nights);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#number_of_reviews")
                    .text(d.number_of_reviews);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#review_time")
                    .text(d.review_time);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#calculated_host_listings_count")
                    .text(d.calculated_host_listings_count);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#availability_365")
                    .text(d.availability_365);

                //Show the tooltip
                d3.select("#tooltip").classed("hidden", false);


            })
            .on("mouseout", function() {
                d3.select(this).style("stroke", "none");
                //d3.select(this).style("stroke-width", 0.15);
                d3.select(this).style("opacity", 0.5);

            });
    }

    update_points(document.getElementById("input_year").value);

    d3.select("#input_year").on("input", function() {
        update_points(+this.value);
    });

    // When a button change, I run the update function
    d3.selectAll("input").on("change", update_points);

    // And I initialize it at the beginning
    update_points()

})



var zooming = function(d) {

    //Log out d3.event.transform, so you can see all the goodies inside
    //console.log(d3.event.transform);

    //New offset array
    var offset = [d3.event.transform.x, d3.event.transform.y];

    //Calculate new scale
    var newScale = d3.event.transform.k * 2000;

    //Update projection with new offset and scale
    projection.translate(offset)
        .scale(newScale);

    //Update all paths and circles
    svg1.selectAll("path")
        .attr("d", path);

    svg1.selectAll("circle")
        .attr("cx", function(d) {
            return projection([d.lon, d.lat])[0];
        })
        .attr("cy", function(d) {
            return projection([d.lon, d.lat])[1];
        });

    svg1.selectAll(".label")
        .attr("x", function(d) {
            return path.centroid(d)[0];
        })
        .attr("y", function(d) {
            return path.centroid(d)[1];
        });

};
</script>
<script>
//var parseTime = d3.timeParse("%Y-%m-%d");
//var mouseoverTime = d3.timeFormat("%a %e %b %Y");
//var minTime = d3.timeFormat("%b%e, %Y");
//var parseDate = d3.timeParse("%b %Y");
var rowConverter = function(d) {
    return {
        pricehigh: parseTime(d.pricehigh),
        price: parseInt(d.price)
    };
}
/* Adapted from: https://bl.ocks.org/mbostock/34f08d5e11952a80609169b7917d4172 */
d3.csv("price.csv", function(data) {


    var data;

    var margin = {
            top: 20,
            right: 20,
            bottom: 90,
            left: 50
        },
        margin2 = {
            top: 230,
            right: 20,
            bottom: 30,
            left: 50
        },
        width = 680 - margin.left - margin.right,
        height = 300 - margin.top - margin.bottom,
        height2 = 300 - margin2.top - margin2.bottom;

    //var parseTime = d3.timeParse("%Y-%m-%d");

    // var local = d3.local();

    var x = d3.scaleLinear().range([0, width]),
        x2 = d3.scaleLinear().range([0, width]),
        y = d3.scaleLinear().range([height, 0]),
        y2 = d3.scaleLinear().range([height2, 0]);
    // dur = d3.scaleLinear().range([0, 12]);

    //var xAxis = d3.axisBottom(x).tickSize(0);
    var xAxis2 = d3.axisBottom(x2).tickSize(0).ticks(20).tickFormat(data.pricehigh)

    yAxis = d3.axisLeft(y).tickSize(0);

    var xAxis = d3.axisBottom(x).ticks(20).tickFormat(data.pricehigh);


    var brush = d3.brushX()
        .extent([
            [0, 0],
            [width, height2]
        ])
        .on("start brush end", brushed);

    var zoom = d3.zoom()
        .scaleExtent([1, 10])
        .translateExtent([
            [0, 0],
            [width, height]
        ])
        .extent([
            [0, 0],
            [width, height]
        ])
        .on("zoom", zoomed);

    var svg2 = d3.select("#svg2")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

    svg2.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);

    var focus = svg2.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var context = svg2.append("g")
        .attr("class", "context")
        .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    // d3.json("data.json", function(error, data) {
    // if (error) throw error;


    data.forEach(function(d) {
            d.pricehigh = +d.pricehigh;
            d.count = +d.count;
            return d;
        },
        function(error, data) {
            if (error) throw error;
        });

    var total = 0;

    data.forEach(function(d) {
        total = d.pricehigh + total;
    });

    var minPrice = d3.min(data, function(d) {
        return d.pricehigh;
    });

    var xMin = d3.min(data, function(d) {
        return d.pricehigh;
    });

    var yMax = d3.max(data, function(d) {
        return d.count;
    });

    x.domain([xMin, d3.max(data, function(d) {
        return d.pricehigh;
    })]);
    y.domain([0, yMax]);
    x2.domain(x.domain());
    y2.domain(y.domain());

    var rects = focus.append("g");
    rects.attr("clip-path", "url(#clip)");
    rects.selectAll("rects")
        .data(data)
        .enter().append("rect")
        .style("fill", function(d) {
            return "#FF5A5F";
        })
        .attr("class", "rects")
        .attr("x", function(d) {
            return x(d.pricehigh);
        })
        .attr("y", function(d) {
            return y(d.count);
        })
        .attr("width", function(d) {
            return 10;
        })
        .attr("height", function(d) {
            return height - y(d.count);
        });

    focus.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

    // Summary Stats
    focus.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Total Counts");

    svg2.append("text")
        .attr("transform",
            "translate(" + ((width + margin.right + margin.left) / 2) + " ," +
            (height + margin.top + margin.bottom) + ")")
        .style("text-anchor", "middle")
        .text("Price");

    svg2.append("rect")
        .attr("class", "zoom")
        .attr("width", width)
        .attr("height", height)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(zoom);

    var rects = context.append("g");
    rects.attr("clip-path", "url(#clip)");
    rects.selectAll("rects")
        .data(data)
        .enter().append("rect")
        .style("fill", function(d) {
            return "#FF5A5F";
        })
        .attr("class", "rects")
        .attr("x", function(d) {
            return x2(d.pricehigh);
        })
        .attr("y", function(d) {
            return y2(d.count);
        })
        .attr("width", function(d) {
            return 10;
        })
        .attr("height", function(d) {
            return height2 - y2(d.count);
        });

    context.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x.range());

    // });

    function brushed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = d3.event.selection || x2.range();
        x.domain(s.map(x2.invert, x2));
        focus.selectAll(".rects")
            .attr("x", function(d) {
                return x(d.pricehigh);
            })
            .attr("y", function(d) {
                return y(d.count);
            })
            .attr("width", function(d) {
                return 10;
            })
            .attr("height", function(d) {
                return height - y(d.count);
            });
        focus.select(".x-axis").call(xAxis);
        svg2.select(".zoom").call(zoom.transform, d3.zoomIdentity
            .scale(width / (s[1] - s[0]))
            .translate(-s[0], 0));
        var e = d3.event.selection;
        var selectedrects = focus.selectAll('.rects').filter(function() {
            var xValue = this.getAttribute('x');
            return e[0] <= xValue && xValue <= e[1];
        });
    }

    function zoomed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
        var t = d3.event.transform;
        x.domain(t.rescaleX(x2).domain());
        focus.selectAll(".rects")
            .attr("x", function(d) {
                return x(d.pricehigh);
            })
            .attr("y", function(d) {
                return y(d.count);
            })
            .attr("width", function(d) {
                return 10;
            })
            .attr("height", function(d) {
                return height - y(d.count);
            });

        focus.select(".x-axis").call(xAxis);
        context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
    }
});
</script>

</html>